#include "HttpServer.hpp"
#include "meta.hpp"
#include <cwchar>
#include <string>

HttpServer::HttpServer() : _b_headers_complete(false), _b_body_complete(false), _current_state(State::ReadingHeaders)
{
	response.set_state(NOT_READY);
	// request.set_header_parsed(false);
	// request.set_body_parsed(false);
}

HttpServer::~HttpServer()
{
	// LOG(RED << "DELETING HTTPSERVER!" << END);
}

HttpServer::HttpServer(const HttpServer &other) : _header_buffer(other._header_buffer), _body_buffer(other._body_buffer), _b_headers_complete(other._b_headers_complete), _b_body_complete(other._b_body_complete), _current_state(other._current_state)
{
	// LOG("HttpServer : copied for sock_fd: " << _socket.get_fd());
}


void	HttpServer::handle(const std::string &data)
{
	on_data_received(data);
}

void		HttpServer::on_data_received(const std::string &data)
{
	switch (_current_state)
	{
		case State::ReadingHeaders:
			handle_headers(data);
			break;
		case State::ReadingBody:
			handle_body(data);
			break;
		case State::GeneratingResponse:
			// response.set_state(_cgi.poll());
			generate_response();
			break;
	}
}

void		HttpServer::handle_headers(const std::string data)
{

	std::stringstream 			stream(data);
	std::string					line;

	LOG_NOTICE(data);
	size_t	header_size = data.find("\r\n\r\n");
	if (header_size != std::string::npos)
	{
		_header_buffer = data.substr(0, header_size);
		LOG_ERROR(_header_buffer);
		exit(123);
		return;
	}
	else {
		_header_buffer += data;
		return;
	}


	try {
		//Read and store to header buffer;
		while (std::getline(stream, line))
		{
			if (!_b_headers_complete)
			{
				if (line[0] == '\r')
				{
					_b_headers_complete = true;
					continue;
				}
				if (line.back() == '\r')
					_header_buffer.append(line + "\n");
				else
					_header_buffer.append(line);
			}
			else if (_b_headers_complete)//If past the header section, store rest of buffer into the body_buffer;
			{
				if (line[0] == '\r')
				{
					_b_body_complete = true;
					LOG_ERROR("WTF");
					continue;
				}
				if (line.back() == '\r')
					_body_buffer.append(line + "\n");
				else
					_body_buffer.append(line);
			}
		}
		LOG_ERROR(_header_buffer);
		LOG_WARNING(_body_buffer);
		if (_b_headers_complete)
		{
			request.parse_header(_header_buffer);
			if (request.get_value("Content-Length").empty())
			{
				LOG_ERROR("NAI");
				_current_state = State::GeneratingResponse;
				generate_response();
			}
			else
			{
				LOG_ERROR("KANKER");
				_current_state = State::ReadingBody;
				handle_body(data);
			}
		}
	} 
	catch (HttpRequest::HttpException &e)
	{
		LOG_ERROR(e.what());
		request.set_type(RequestType::BadRequest);
		_current_state = State::GeneratingResponse;
	}
}

void		HttpServer::handle_body(const std::string &data)
{
	if (_b_body_complete)
	{
		_current_state = State::GeneratingResponse;
		generate_response();
	}
	std::stringstream 			stream(data);
	std::string					line;
	while (std::getline(stream, line))
	{
		if (line.back() == '\r')
			_body_buffer.append(line + "\n");
		else
			_body_buffer.append(line);
	}
	if (line.empty())
	{
		_b_body_complete = true;
		request.parse_body(_body_buffer);
		_current_state = State::GeneratingResponse;
		generate_response();
	}
	LOG_DEBUG("KNAI" << line);

	std::string boundary = request.get_value("Content-Type");
	if (!boundary.empty() && !_b_body_complete)
	{
		boundary = boundary.substr(boundary.find("WebKitFormBoundary"), boundary.rfind("\r"));
		boundary.erase(std::find_if(boundary.rbegin(), boundary.rend(), [](unsigned char ch) {
					return !std::isspace(ch);
					}).base(), boundary.end());
		if (_body_buffer.rfind("------" + boundary + "--\r") != std::string::npos)
		{
			_b_body_complete = true;
			request.parse_body(_body_buffer);
			_current_state = State::GeneratingResponse;
			generate_response();
		}
	}
}

void		HttpServer::generate_response()
{
	auto handler = HandlerFactory::create_handler(request.get_type());
	response = handler->handle_request(request, TEST_CONFIG);
	if (response.get_type() == ResponseType::CGI)
		_cgi.start("sleep_echo_var");
}

std::string	HttpServer::get_data()
{
	if (!response.is_ready())
	{
		WARNING("calling get_data() while not ready!");
	}
	if (response.get_type() == ResponseType::CGI)
	{
		std::string b = _cgi.get_buffer();
		response.append_body(b);
	}
	return response.to_string();
}

bool		HttpServer::is_ready()
{
	return this->response.is_ready();
}

void 		HttpServer::poll_cgi()
{
	if (response.get_type() == ResponseType::REGULAR)
		return;
	else
		response.set_state(_cgi.poll());
}

